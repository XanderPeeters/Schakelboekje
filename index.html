<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Map OpenLayers</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"> <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.4/xlsx.full.min.js"></script> <!-- Include SheetJS library -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            left: 300px;
            bottom: 30px;
            width: calc(100% - 300px);
        }



        #logoAndEditorContainer {
            display: flex; /* Use flexbox to align items horizontally */
            align-items: center; /* Center items vertically */
            margin-bottom: 10px; /* Add margin at the bottom */
        }

        #logoContainer,
        #editorLoginContainer {
            margin-right: 10px; /* Add margin between the logo and login button */
        }


        #editorLoginButton {
            padding: 5px; /* Adjust padding */
            font-size: 12px; /* Adjust font size */
            height: 40px; /* Set the height to match the logo */
            width: 100px;
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
            margin-left: 50px;
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            height: calc(100% - 40px);
            width: 300px;
            background-color: #f8f9fa; /* Light gray background */
            padding: 10px;
            box-sizing: border-box;
            text-align: left; /* Align text to the left */
        }

        .pointer {
            position: absolute;
            top: -22px;
            left: -9px;
            font-size: 24px;
            color: blue;
            z-index: 1000;
        }

        .legend {
            position: absolute;
            bottom: 40px;
            left: 310px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .popup {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 10px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            bottom: 35px;
            right: 10px;
            width: 200px;
            height: 300px;
            overflow: scroll;
            max-height: 300px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .control-box {
            margin-bottom: 10px;
        }

        .control-box label {
            display: block; /* Each label on a new line */
            margin-bottom: 5px; /* Add space between labels */
            font-weight: bold; /* Make label text bold */
        }

        .control-box input[type="text"],
        .control-box input[type="range"],
        .control-box button {
            width: 100%; /* Take up full width */
            padding: 5px; /* Add padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .control-box button {
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
        }

        .control-box button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        .export-button {
            padding: 5px; /* Adjust padding */
            font-size: 12px; /* Adjust font size */
            height: 40px; /* Set the height to match the other buttons */
            width: 100px; /* Set the width */
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
            margin-left: 0px; /* Adjust margin */
            border-radius: 5px; /* Add border radius */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add shadow */
        }

        .export-button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

    </style>
</head>
<body>
<div id="controls">
    <div class="control-box" id="logoAndEditorContainer">
        <div id="logoContainer">
            <img src="https://github.com/XanderPeeters/Schakelboekje/blob/master/De_Lijn.svg.png?raw=true" alt="De Lijn logo" width="75" height="auto" onclick="reloadPage()">
        </div>
        <div id="editorLoginContainer">
            <button id="editorLoginButton" onclick="openEditorLoginPage()">Editor page</button>
        </div>
    </div>
    <div class="control-box">
        <label for="visible_map">Kaart:</label>
        <input id="visible_map" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible_switches">Sectie schakelaars:</label>
        <input id="visible_switches" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible_feeders">Voedingen:</label>
        <input id="visible_feeders" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible_Grey">Grijze achtergrond:</label>
        <input id="visible_Grey" type="checkbox"/>
    </div>
    <div class="control-box">
        <label for="opacity_switches">Transparantie schakelaars:</label>
        <input id="opacity_switches" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="opacity_feeders">Transparantie voedingen:</label>
        <input id="opacity_feeders" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="searchInput">Zoek op adres, voeding of schakelaar:</label>
        <input id="searchInput" type="text"/>
    </div>
    <div class="control-box">
        <button onclick="searchLayerFeatureOrAddress()">Zoeken</button>
        <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
    </div>
    <div class="control-box">
        <button id="draw_Button" onclick="toggleDrawing()">Teken</button>
    </div>
</div>
<div id="map"></div>
<div id="popup" class="popup" style="display: none;"></div>
<div class="legend">
    <label>Legende:</label>
    <div>
        <i class="fas fa-dot-circle" style="color: red;"></i> <span style="color: red;">Gesloten</span><br>
        <i class="fas fa-dot-circle" style="color: green;"></i> <span style="color: green;">Open</span>
    </div>
</div>

<script>
    let map;
    let draw;

    function openEditorLoginPage() {
        window.location.href = "login.html"; // Redirect to the user page again
    }

    // Function to find the switches corresponding to a given main feeder
    async function find_switches(Main_feeder) {
        // Load JSON file from server
        const response = await fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/sectieschakelaars.json'); // Update the path as needed
        const jsonData = await response.json();

        // Find the corresponding switches for the given main feeder
        const sValueRow = jsonData.find(row => row[0] === Main_feeder);

        // Return the switches if found
        return sValueRow ? sValueRow[1] : 'Not found';
    }

    const center = ol.proj.fromLonLat([4.4024643, 51.2194475]);
    const extentSize = 25000; // Size of the extent in meters (10 km = 10000 meters)
    const extent = ol.extent.buffer(center.concat(center), extentSize);

    const view = new ol.View({
        center: center,
        zoom: 13,
        extent: extent // Set the extent
    });

    let pinClicked = false;
    let drawingModeActive = false;
    let drawnFeaturesSource = new ol.source.Vector(); // Source to hold drawn features
    let drawnFeaturesLayer = new ol.layer.Vector({ // Layer to display drawn features
        source: drawnFeaturesSource,
    });

    map = new ol.Map({
        layers: [
            new ol.layer.Tile({
                source: new ol.source.TileJSON({
                    url: 'https://api.maptiler.com/maps/basic-v2/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
                    tileSize: 512,
                })
            })
        ],
        target: 'map',
        view: view // Use the view with the custom extent
    });

    const pointerElement = document.createElement('i');
    pointerElement.className = 'pointer fa-solid fa-location-dot';
    const pointerOverlay = new ol.Overlay({
        element: pointerElement,
        positioning: 'center-center',
        stopEvent: false
    });
    map.addOverlay(pointerOverlay);

    function toggleDrawing() {
        drawnFeaturesSource.clear(); // Clear previously drawn features
        if (drawingModeActive) {
            map.removeInteraction(draw);
            document.getElementById('draw_Button').style.backgroundColor = '';
        } else {
            document.getElementById('draw_Button').style.backgroundColor = 'green';
            initDrawingInteraction();

        }
        drawingModeActive = !drawingModeActive;
    }

    function initDrawingInteraction() {
        
        draw = new ol.interaction.Draw({
            source: drawnFeaturesSource,
            type: 'Polygon',
        });
        map.addInteraction(draw);

        draw.on('drawend', async function(event) {
            // Clear previous polygon
            drawnFeaturesSource.clear();

            // Lock the current polygon
            const polygonFeature = event.feature;
            const polygonGeometry = polygonFeature.getGeometry();

            polygonFeature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'blue',
                    width: 2,
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(0, 0, 255, 0.2)',
                }),
            }));

            // Add the drawn feature to the permanent layer
            drawnFeaturesSource.addFeature(polygonFeature);

            // Perform spatial query against features in feeder layer
            const intersectingFeatures = new Set();
            const polygonExtent = polygonGeometry.getExtent();

            const features = feeder_layer.getSource().getFeatures();
            await Promise.all(features.map(async (feature) => {
                const featureGeometry = feature.getGeometry();
                const featureExtent = featureGeometry.getExtent();
                if (ol.extent.intersects(polygonExtent, featureExtent)) {
                    const layerName = feature.get('LAYER');
                    const Main_feeder = layerName;
                    const switches = await find_switches(Main_feeder);
                    const edgeFeedersSet = findEdgeFeeders(Main_feeder); // Call the function to find edge feeders
                    const edgeFeeders = [...edgeFeedersSet]; // Convert Set to Array for easier handling
                    let layerData = { layerName: Main_feeder, edgeFeeders: edgeFeeders, Switches: switches };
                    let isNewLayer = true;
                    for (let data of intersectingFeatures) {
                        if (data.layerName === layerName) {
                            isNewLayer = false;
                            break;
                        }
                    }
                    if (isNewLayer) {
                        intersectingFeatures.add(layerData);
                    }
                }
            }));

            // Display popup with information about intersecting features
            handlePinClick();
            const popupElement = document.querySelector('.popup');
            if (intersectingFeatures.size > 0) {
                const popupContent = Array.from(intersectingFeatures).map(function(data) {
                    const feederName = data.layerName;
                    const edgeFeeders = data.edgeFeeders;
                    const switches = data.Switches
                    // Populate the tsFeederMap object with main and edge feeder names
                     const tsFeederMap = populateTSFeederMap([feederName, ...edgeFeeders]);

                    // Generate the "Feeders to turn off" section content
                    let feedersToTurnOffContent = '<p>Feeders to turn off:</p>';
                    for (const tsNumber in tsFeederMap) {
                        const feederList = tsFeederMap[tsNumber].join(', ');
                        // Include a message for "N/A" TS numbers
                        const tsNumberDisplay = tsNumber !== 'N/A' ? `TS ${tsNumber}` : 'No corresponding TS-number';
                        feedersToTurnOffContent += `<p>${tsNumberDisplay}: ${feederList}</p>`;
                    }

                    return `<h4 style="margin-top: 0;">Location information:</h4><p>Main feeder: ${feederName}</p><p>Edge feeders: ${edgeFeeders}</p><p>Switches: ${switches}</p> ${feedersToTurnOffContent}`;
                }).join('<hr>'); // Separate feature information with horizontal line
                popupElement.innerHTML = popupContent;
                // Add the export button separately outside of the mapping function
                popupElement.innerHTML += '<button id="exportButton" class="export-button">Export to Word</button>';

            } else {
                // If no intersecting features, display a message
                popupElement.style.display = 'none';
            }

            // Clear the drawing interaction (but keep it active)
            draw.finishDrawing();
        });
    }

    map.on('click', async function(event) {
    if (drawingModeActive) {
        //No functionality yet
    } else {
        handlePinClick();
        const popupElement = document.querySelector('.popup');
        const coordinates = event.coordinate;
        const transfcoordinates = ol.proj.transform(coordinates, 'EPSG:3857', 'EPSG:4326'); // Correct variable name
        let closestFeature = null;
        let closestDistance = Infinity; // Initialize with infinity
        feeder_layer.getSource().forEachFeature(function(feature) {
            const featureCoordinates = feature.getGeometry().getClosestPoint(coordinates);
            const featureCoords = ol.proj.transform(featureCoordinates, 'EPSG:3857', 'EPSG:4326');
            const distance = ol.sphere.getDistance(transfcoordinates, featureCoords);
            if (distance < closestDistance) {
                closestDistance = distance;
                closestFeature = feature;
            }
        });

        // Check if distance exceeds the threshold (for example, 1000 meters)
        if (closestDistance <= 500) {
            if (closestFeature) {
                const closestFeatureName = closestFeature.get('LAYER');
                const lon = transfcoordinates[0];
                const lat = transfcoordinates[1];
                const Main_feeder = closestFeatureName;
                const Switches = await find_switches(Main_feeder);
                const edgeFeedersSet = findEdgeFeeders(Main_feeder); // Call the function to find edge feeders
                const edgeFeeders = [...edgeFeedersSet]; // Convert Set to Array for easier handling
                // Populate the tsFeederMap object with main and edge feeder names
                 const tsFeederMap = populateTSFeederMap([closestFeatureName, ...edgeFeeders]);

                // Generate the "Feeders to turn off" section content
                let feedersToTurnOffContent = '<p>Feeders to turn off:</p>';
                for (const tsNumber in tsFeederMap) {
                    const feederList = tsFeederMap[tsNumber].join(', ');
                    // Include a message for "N/A" TS numbers
                    const tsNumberDisplay = tsNumber !== 'N/A' ? `TS ${tsNumber}` : 'No corresponding TS-number';
                    feedersToTurnOffContent += `<p>${tsNumberDisplay}: ${feederList}</p>`;
                }


                 // Add the generated content to the main content string
                const content = `<h4 style="margin-top: 0;">Location information:</h4>
                                 <p>Main feeder: ${Main_feeder}</p>
                                 <p>Edge feeders: ${edgeFeeders}</p>
                                 <p>Switches: ${Switches}</p>
                                 ${feedersToTurnOffContent}
                                 <button id="exportButton" class="export-button">Export to Word</button>`;
                popupElement.innerHTML = content;
            } else {
                const lon = transfcoordinates[0];
                const lat = transfcoordinates[1];
                const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
                popupElement2.innerHTML = content;
            }
        } else {
            popupElement.style.display = 'none'; // Hide the popup if distance exceeds threshold
        }
    pointerOverlay.setPosition(coordinates);
    }
});

    // Function to handle the pin click event
    function handlePinClick() {
        pinClicked = true;
        const popupElement = document.getElementById('popup');
        if (pinClicked) {
            popupElement.style.display = 'block';
        } else {
            popupElement.style.display = 'none';
        }
    }

    //Function to find the TS number for a given feeder name
    function findTSNumber(feederName) {
        // Loop through each feature in the GeoJSON data
        for (const feature of Feeder_Source.getFeatures()) {
            // Check if the feature's 'LAYER' name matches the given feederName
            if (feature.get('LAYER') === feederName) {
                // Return the TS number of the matched feature
                const tsNumber = feature.get('TS');
                return tsNumber !== null ? tsNumber : 'N/A'; // Return "N/A" if TS number is null
            }
        }
        // Return "N/A" if no matching feeder name is found
        return 'N/A';
    }


    // Create an object to store TS numbers and associated feeder names
    const tsFeederMap = {};

    // Function to populate the tsFeederMap object
    function populateTSFeederMap(feederNames) {
        const tsFeederMap = {}; // Clear tsFeederMap object
        feederNames.forEach(feederName => {
            const tsNumber = findTSNumber(feederName);
            if (tsNumber) {
                if (!tsFeederMap[tsNumber]) {
                    tsFeederMap[tsNumber] = [feederName];
                } else {
                    tsFeederMap[tsNumber].push(feederName);
                }
            }
        });
        return tsFeederMap; // Return the populated tsFeederMap object
    }



    // Add a click event listener to the pin element
    pointerElement.addEventListener('click', function(event) {
        // Prevent the singleclick event on the map from firing
        event.stopPropagation();
        handlePinClick();
    });

    map.on('dblclick', function(event) {
        if (drawingModeActive) {
            // Prevent map zoom on double-click during drawing mode
            event.preventDefault();
        }
    });

    map.getViewport().addEventListener('contextmenu', function(event) {
        if (drawingModeActive) {
            // Finish drawing on right-click
            event.preventDefault();
            draw.finishDrawing();

        } else {
           // Prevent the default context menu from appearing
           event.preventDefault();
           // Hide the pointer
           pointerOverlay.setPosition(undefined);
           const popupElement = document.getElementById('popup');
           popupElement.style.display = 'none';
        }
    });
    map.addLayer(drawnFeaturesLayer);

    // Object to store the colors for each layer
    const layerColors = {};

    // Load GeoJSON data for the first layer
    const Switches_source = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/schakelaars2.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the first layer (dots) with red/green color and label
    const Switch_styling = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property;
        const plaats = feature.get('PLAATS'); // Get the 'PLAATS' attribute
        const detail = feature.get('DETAIL1');
        const color = 'red'; // Set color to red
        // Create style for the feature
        return new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: color // Use the color
                }),
                stroke: new ol.style.Stroke({
                    color: color, // Use the color
                    width: 2
                })
            }),
            text: new ol.style.Text({
                text: map.getView().getZoom() >= 15 ? (map.getView().getZoom() >= 20 ? layerName + (plaats ? ' - ' + plaats : '') + (detail ? ' - ' + detail : '') : layerName) : '', // Show layer name from zoom level 15 and add 'PLAATS' from zoom level 20
                font: 'bold 12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: 'black' }) // Use the same color for the label
            })
        });
    };

    function findEdgeFeeders(mainFeederName) {
    const edgeFeedersSet = new Set();

    // Find all instances of the main feeder
    const mainFeederFeatures = [];
    feeder_layer.getSource().forEachFeature(function(feature) {
        const featureName = feature.get('LAYER');
        if (featureName === mainFeederName) {
            mainFeederFeatures.push(feature);
        }
    });

    // Iterate through main feeder instances and find intersecting edge feeders
    mainFeederFeatures.forEach(function(mainFeederFeature) {
        const mainFeederGeometry = mainFeederFeature.getGeometry();
        feeder_layer.getSource().forEachFeature(function(innerFeature) {
            const innerFeatureName = innerFeature.get('LAYER');
            if (innerFeatureName !== mainFeederName && mainFeederGeometry.intersectsExtent(innerFeature.getGeometry().getExtent())) {
                edgeFeedersSet.add(innerFeatureName); // Add to the Set
            }
        });
    });

    return edgeFeedersSet;
}


    // Load GeoJSON data for the grey map layer
    const greyMapSource = new ol.source.TileJSON({
        url: 'https://api.maptiler.com/maps/basic-v2-light/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
        tileSize: 512,
    });

    // Create the grey map layer
    const greyMapLayer = new ol.layer.Tile({
        source: greyMapSource,
        visible: false // Initially set to invisible
    });

    // Add the grey map layer to the map
    map.addLayer(greyMapLayer);


    // Create the first vector layer
    const switches_layer = new ol.layer.Vector({
        source: Switches_source,
        style: Switch_styling
    });

    // Add the first vector layer to the mapp
    map.addLayer(switches_layer);

    // Load GeoJSON data for the second layer
    const Feeder_Source = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/Voedingen-stadsplan.geojson',
        format: new ol.format.GeoJSON()
    });


    // Create the second vector layer without style
    const feeder_layer = new ol.layer.Vector({
        source: Feeder_Source
    });

    // Add the second vector layer to the map
    map.addLayer(feeder_layer);

    // Fetch JSON data from the server
    fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/Kleuren.json')
        .then(response => {
            return response.json();
        })
        .then(data => {
            // Define a map to store colors for feeders
            const feederColors = new Map(data.map(entry => [entry.LAYER, entry.COLOR]));

            // Modified style function to use assigned colors for feeders
            const Feeder_styling = function(feature) {
                const layerName = feature.get('LAYER'); // Get the name of the feeder from the 'LAYER' property

                // Get color for the current feeder from the map
                const color = feederColors.get(layerName);

                // If color is found, create style for the feature
                if (color) {
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 3
                        }),
                        text: new ol.style.Text({
                            text: map.getView().getZoom() >= 15 ? layerName : '', // Show label only from zoom level 15
                            font: 'bold 12px Calibri,sans-serif',
                            offsetY: -12,
                            fill: new ol.style.Fill({ color: 'black' })
                        })
                    });
                } else {
                    // If color is not found, handle as needed
                    console.error('Color not found for layer:', layerName);
                    // You can choose to assign a default color or handle the situation differently
                    return null;
                }
            };

            // Set style function for the vector layer
            feeder_layer.setStyle(Feeder_styling);
        });
        

    // Function to handle layer visibility
    function handleLayerVisibility(layer, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        checkbox.addEventListener('change', function() {
            layer.setVisible(this.checked);
        });
    }

    // Function to handle layer opacity
    function handleLayerOpacity(layer, rangeId) {
        const rangeInput = document.getElementById(rangeId);
        rangeInput.addEventListener('input', function() {
            layer.setOpacity(parseFloat(this.value));
        });
        rangeInput.value = String(layer.getOpacity());
    }

    const popupElement = document.getElementById('popup');
    popupElement.addEventListener('click', function(event) {
        if (event.target.id === 'exportButton') {
             const content = popupElement.innerHTML;
            exportToWord(content);
        }
    });


    function exportToWord(content) {

        const contentWithoutButton = content.replace('<button id="exportButton" class="export-button">Export to Word</button>', '');

        // Create a new Blob object containing the content
        const blob = new Blob([`<html><body>${contentWithoutButton}</body></html>`], { type: 'application/msword' });

        // Create a temporary anchor element
        const anchor = document.createElement('a');
        anchor.download = 'location_info.doc';

        // Create a URL for the Blob object
        anchor.href = URL.createObjectURL(blob);

        // Append the anchor to the body and programmatically click it to trigger the download
        document.body.appendChild(anchor);
        anchor.click();

        // Remove the anchor element after the download
        document.body.removeChild(anchor);
    }

    //function to zoom to a specific location
    function zoomToLocationOrLayer(feature) {
        const extent = feature.getGeometry().getExtent();
        map.getView().fit(extent, {duration: 1000});
    }

    // Function to zoom to a specific location or layer
    function searchLayerFeatureOrAddress() {
        const searchText = document.getElementById('searchInput').value;
        if (!searchText) {
            document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
            return;
        }
        let found = false;
        const layers = [feeder_layer, switches_layer];

        layers.forEach(layer => {
            layer.getSource().forEachFeature(feature => {
                if (feature.get('LAYER') === searchText) {
                    zoomToLocationOrLayer
                    found = true;
                    return;
                }
            });
        });

        if (!found) {
            geocodeAddress(searchText);
        } else {
            document.getElementById('errorMessage').textContent = ''; // Clear error message
        }
    }
           


    // Function to geocode an address and zoom to its location
    function geocodeAddress(address) {
        const postalcode = '2000';
        const city = 'Antwerpen';
        const fullAddress = address + ', ' + city + ', ' + postalcode;
        const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(fullAddress);
        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                if (data && data.length > 0) {
                    const location = data[0];
                    const coordinates = [parseFloat(location.lon), parseFloat(location.lat)];
                    map.getView().animate({ center: ol.proj.fromLonLat(coordinates), zoom: 18, duration: 1000 });
                } else {
                    document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
                }
            })
    }

    function reloadPage() {
        location.reload();
    }

    // Handle visibility for OSM layer
    handleLayerVisibility(map.getLayers().item(0), 'visible_map');

    // Handle visibility for QGIS layer 1
    handleLayerVisibility(switches_layer, 'visible_switches');

    // Handle visibility for QGIS layer 2
    handleLayerVisibility(feeder_layer, 'visible_feeders');

    // Handle visibility for greylayer
    handleLayerVisibility(greyMapLayer, 'visible_Grey');

    // Handle opacity for QGIS layer 1
    handleLayerOpacity(switches_layer, 'opacity_switches');

    // Handle opacity for QGIS layer 2
    handleLayerOpacity(feeder_layer, 'opacity_feeders');
</script>
</body>
</html>