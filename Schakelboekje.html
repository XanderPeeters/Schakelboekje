<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Map OpenLayers</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"> <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            left: 300px; /* Adjust as needed */
            bottom: 30px; /* Adjust as needed */
            width: calc(100% - 300px); /* Adjust as needed */
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            height: calc(100% - 40px); /* Adjust as needed */
            width: 300px;
            background-color: #f8f9fa; /* Light gray background */
            padding: 10px;
            box-sizing: border-box;
            text-align: left; /* Align text to the left */
            overflow-y: auto;
        }

        .pointer {
            font-size: 24px; /* Adjust icon size as needed */
            color: red; /* Change color as needed */
            position: absolute;
            z-index: 1000;
         }

         .popup {
            position: absolute;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            top: 20px;
            right: 20px;
        }

        .control-box {
            margin-bottom: 10px;
        }

        .control-box label {
            display: block; /* Each label on a new line */
            margin-bottom: 5px; /* Add space between labels */
            font-weight: bold; /* Make label text bold */
        }

        .control-box input[type="text"],
        .control-box input[type="range"],
        .control-box button {
            width: 100%; /* Take up full width */
            padding: 5px; /* Add padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .control-box button {
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
        }

        .control-box button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
    </style>
</head>
<body>
<div id="popup" class="popup"></div>
<div id="controls">
    <div class="control-box">
        <label for="visible0">Kaart:</label>
        <input id="visible0" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible1">Sectie schakelaars:</label>
        <input id="visible1" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible2">Voedingen:</label>
        <input id="visible2" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="opacity1">Transparantie schakelaars:</label>
        <input id="opacity1" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="opacity2">Transparantie voedingen:</label>
        <input id="opacity2" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="searchInput">Zoek op adres, voeding of schakelaar:</label>
        <input id="searchInput" type="text"/>
    </div>
    <div class="control-box">
        <button onclick="zoomToLocationOrLayer()">Zoeken</button>
        <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
    </div>
</div>
<div id="map"></div>

<script>
    const center = ol.proj.fromLonLat([4.4024643, 51.2194475]);
    const extentSize = 25000; // Size of the extent in meters (10 km = 10000 meters)
    const extent = ol.extent.buffer(center.concat(center), extentSize);

    const view = new ol.View({
        center: center,
        zoom: 13,
        extent: extent // Set the extent
    });

    const map = new ol.Map({
        layers: [
            new ol.layer.Tile({
                source: new ol.source.TileJSON({
                    url: 'https://api.maptiler.com/maps/basic-v2/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
                    tileSize: 512,
                })
            })
        ],
        target: 'map',
        view: view // Use the view with the custom extent
    });

    const pointerElement = document.createElement('i');
    pointerElement.className = 'pointer fa-solid fa-location-dot';
    const pointerOverlay = new ol.Overlay({
        element: pointerElement,
        positioning: 'center-center',
        stopEvent: false
    });
    map.addOverlay(pointerOverlay);

    const popupElement = document.getElementById('popup');
    const popupOverlay = new ol.Overlay({
        element: popupElement,
        positioning: 'top-right',
        offset: [0, -10],
        stopEvent: false
    });
    map.addOverlay(popupOverlay);

    map.on('click', function(event) {
    const clickedCoordinates = event.coordinate;

    // Transform the clicked coordinates to the same projection as the features
    const clickedCoords = ol.proj.transform(clickedCoordinates, 'EPSG:3857', 'EPSG:4326');

    // Find the closest feature in the "voedingen3" layer
    let closestFeature = null;
    let closestDistance = Infinity;
    vectorLayer2.getSource().forEachFeature(function(feature) {
        // Transform the feature coordinates to the same projection as the clicked coordinates
        const featureCoordinates = feature.getGeometry().getClosestPoint(clickedCoordinates);
        const featureCoords = ol.proj.transform(featureCoordinates, 'EPSG:3857', 'EPSG:4326');

        // Calculate the distance using transformed coordinates
        const distance = ol.sphere.getDistance(clickedCoords, featureCoords);
        if (distance < closestDistance) {
            closestDistance = distance;
            closestFeature = feature;
        }
    });

    // Display the popup with information
    if (closestFeature) {
        const closestFeatureName = closestFeature.get('LAYER');
        const lon = clickedCoordinates[0];
        const lat = clickedCoordinates[1];
        const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p><p>Closest Feature: ${closestFeatureName}</p>`;
        popupElement.innerHTML = content;
        popupOverlay.setPosition(clickedCoordinates);
    } else {
        // If no feature found, display coordinates only
        const lon = clickedCoordinates[0];
        const lat = clickedCoordinates[1];
        const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
        popupElement.innerHTML = content;
        popupOverlay.setPosition(clickedCoordinates);
    }

    // Display the pointer at the clicked coordinates
    pointerOverlay.setPosition(clickedCoordinates);
});

    // Object to store the colors for each layer
    const layerColors = {};

    // Load GeoJSON data for the first layer
    const geojsonSource1 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/schakelaars2.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the first layer (dots) with red/green color and label
    const geojsonStyle1 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property;
        const color = 'red'; // Set color to red
        // Create style for the feature
        return new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: color // Use the color
                }),
                stroke: new ol.style.Stroke({
                    color: color, // Use the color
                    width: 2
                })
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the first vector layer
    const vectorLayer1 = new ol.layer.Vector({
        source: geojsonSource1,
        style: geojsonStyle1
    });

    // Add the first vector layer to the map
    map.addLayer(vectorLayer1);

    // Load GeoJSON data for the second layer
    const geojsonSource2 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voedingen3.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the second layer (lines) with dynamic color and label
    const geojsonStyle2 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property
        let color;
        if (layerColors[layerName]) {
            // If color is already assigned, reuse it
            color = layerColors[layerName];
        } else {
            // Otherwise, generate a new random color and store it
            color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            layerColors[layerName] = color;
        }
        // Create style for the feature
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: color, // Use the color
                width: 3
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the second vector layer with the dynamic style function
    const vectorLayer2 = new ol.layer.Vector({
        source: geojsonSource2,
        style: geojsonStyle2
    });

    // Add the second vector layer to the map
    map.addLayer(vectorLayer2);

    // Function to handle layer visibility
    function handleLayerVisibility(layer, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        checkbox.addEventListener('change', function() {
            layer.setVisible(this.checked);
        });
    }

    // Function to handle layer opacity
    function handleLayerOpacity(layer, rangeId) {
        const rangeInput = document.getElementById(rangeId);
        rangeInput.addEventListener('input', function() {
            layer.setOpacity(parseFloat(this.value));
        });
        rangeInput.value = String(layer.getOpacity());
    }

    function zoomToLocationOrLayer() {
        const searchText = document.getElementById('searchInput').value;
        // Clear previous error message
        document.getElementById('errorMessage').textContent = '';
        if (searchText) {
            let foundLayer2 = false;
            let foundLayer1 = false;
            // Check if the search text matches a feature in Layer 2
            vectorLayer2.getSource().forEachFeature(function(feature) {
                if (feature.get('LAYER') === searchText) {
                    const extent = feature.getGeometry().getExtent();
                    map.getView().fit(extent, { duration: 1000 });
                    const coordinates = ol.extent.getCenter(extent);
                    displayLayerPinAndPopup(coordinates); // Display pin and popup at the location
                    foundLayer2 = true;
                    return;
                }
            });
            // If not found in Layer 2, check Layer 1
            if (!foundLayer2) {
                vectorLayer1.getSource().forEachFeature(function(feature) {
                    if (feature.get('LAYER') === searchText) {
                        const extent = feature.getGeometry().getExtent();
                        map.getView().fit(extent, { duration: 1000 });
                        const coordinates = ol.extent.getCenter(extent);
                        displayLayerPinAndPopup(coordinates); // Display pin and popup at the location
                        foundLayer1 = true;
                        return;
                    }
                });
            }

            // If not found in Layer 1 or Layer 2, attempt to geocode address
            if (!foundLayer2 && !foundLayer1) {
                geocodeAddress(searchText); // Attempt to geocode the address
            }
        } else {
             document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
        }
    }

    // Function to geocode an address and zoom to its location
    function geocodeAddress(address) {
        const postalcode = '2000';
        const city = 'Antwerpen';
        const query = encodeURIComponent(address) + ' ' + postalcode + ' ' + city;
        const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + query;
        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                if (data && data.length > 0) {
                    const location = data[0];
                    const coordinates = [parseFloat(location.lon), parseFloat(location.lat)];
                    map.getView().animate({ center: ol.proj.fromLonLat(coordinates), zoom: 18, duration: 1000 });
                    displayAddressPinAndPopup(coordinates); // Pass coordinates instead of extent
                } else {
                    document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
                }
            })
            .catch(function(error) {
                console.error('Error geocoding address:', error);
            });
    }


    function displayAddressPinAndPopup(coordinates) {
        const lon = coordinates[0];
        const lat = coordinates[1];
        const position = ol.proj.fromLonLat([lon, lat]);

        // Remove existing pin and popup
        pointerOverlay.setPosition(undefined);
        popupOverlay.setPosition(undefined);

        // Set pin position
        pointerOverlay.setPosition(position);

        // Display popup
        const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
        popupElement.innerHTML = content;
        popupOverlay.setPosition(position);
    }

    function displayLayerPinAndPopup(extent) {
        const center = ol.extent.getCenter(extent);
        const lon = center[0];
        const lat = center[1];
        const position = ol.proj.fromLonLat([lon, lat]);

        // Remove existing pin and popup
        pointerOverlay.setPosition(undefined);
        popupOverlay.setPosition(undefined);

        // Set pin position
        pointerOverlay.setPosition(position);

        // Display popup
        const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
        popupElement.innerHTML = content;
        popupOverlay.setPosition(position);
    }

    // Handle visibility for OSM layer
    handleLayerVisibility(map.getLayers().item(0), 'visible0');

    // Handle visibility for QGIS layer 1
    handleLayerVisibility(vectorLayer1, 'visible1');

    // Handle visibility for QGIS layer 2
    handleLayerVisibility(vectorLayer2, 'visible2');

    // Handle opacity for QGIS layer 1
    handleLayerOpacity(vectorLayer1, 'opacity1');

    // Handle opacity for QGIS layer 2
    handleLayerOpacity(vectorLayer2, 'opacity2');
</script>
</body>
</html>