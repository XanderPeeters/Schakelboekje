<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Map OpenLayers</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            left: 300px; /* Adjust as needed */
            bottom: 30px; /* Adjust as needed */
            width: calc(100% - 300px); /* Adjust as needed */
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            height: calc(100% - 40px); /* Adjust as needed */
            width: 300px;
            background-color: #f8f9fa; /* Light gray background */
            padding: 10px;
            box-sizing: border-box;
            text-align: left; /* Align text to the left */
            overflow-y: auto;
        }

        .control-box {
            margin-bottom: 10px;
        }

        .control-box label {
            display: block; /* Each label on a new line */
            margin-bottom: 5px; /* Add space between labels */
            font-weight: bold; /* Make label text bold */
        }

        .control-box input[type="text"],
        .control-box input[type="range"],
        .control-box button {
            width: 100%; /* Take up full width */
            padding: 5px; /* Add padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .control-box button {
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
        }

        .control-box button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
    </style>
</head>
<body>
<div id="controls">
    <div class="control-box">
        <label for="visible0">Kaart:</label>
        <input id="visible0" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible1">Sectie schakelaars:</label>
        <input id="visible1" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible2">Voedingen:</label>
        <input id="visible2" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="opacity1">Transparantie schakelaars:</label>
        <input id="opacity1" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="opacity2">Transparantie voedingen:</label>
        <input id="opacity2" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="searchInput">Zoek op adres, voeding of schakelaar:</label>
        <input id="searchInput" type="text"/>
    </div>
    <div class="control-box">
        <button onclick="zoomToLocationOrLayer()">Zoeken</button>
        <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
    </div>
</div>
<div id="map"></div>

<script>
    const center = ol.proj.fromLonLat([4.4024643, 51.2194475]);
    const extentSize = 25000; // Size of the extent in meters (10 km = 10000 meters)
    const extent = ol.extent.buffer(center.concat(center), extentSize);

    const view = new ol.View({
        center: center,
        zoom: 13,
        extent: extent // Set the extent
    });

    const map = new ol.Map({
        layers: [
            new ol.layer.Tile({
                source: new ol.source.TileJSON({
                    url: 'https://api.maptiler.com/maps/basic-v2/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
                    tileSize: 512,
                })
            })
        ],
        target: 'map',
        view: view // Use the view with the custom extent
    });

    // Object to store the colors for each layer
    const layerColors = {};

    // Load GeoJSON data for the first layer
    const geojsonSource1 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/schakelaars2.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the first layer (dots) with red/green color and label
    const geojsonStyle1 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property;
        const color = 'red'; // Set color to red
        // Create style for the feature
        return new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: color // Use the color
                }),
                stroke: new ol.style.Stroke({
                    color: color, // Use the color
                    width: 2
                })
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the first vector layer
    const vectorLayer1 = new ol.layer.Vector({
        source: geojsonSource1,
        style: geojsonStyle1
    });

    // Add the first vector layer to the map
    map.addLayer(vectorLayer1);

    // Load GeoJSON data for the second layer
    const geojsonSource2 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voedingen3.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the second layer (lines) with dynamic color and label
    const geojsonStyle2 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property
        let color;
        if (layerColors[layerName]) {
            // If color is already assigned, reuse it
            color = layerColors[layerName];
        } else {
            // Otherwise, generate a new random color and store it
            color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            layerColors[layerName] = color;
        }
        // Create style for the feature
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: color, // Use the color
                width: 3
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the second vector layer with the dynamic style function
    const vectorLayer2 = new ol.layer.Vector({
        source: geojsonSource2,
        style: geojsonStyle2
    });

    // Add the second vector layer to the map
    map.addLayer(vectorLayer2);

    // Troubleshooting: Add an event listener to check for errors
    vectorLayer2.getSource().on('change', function(evt) {
        if (vectorLayer2.getSource().getState() === 'ready') {
            console.log('Data loaded successfully.');
        } else if (vectorLayer2.getSource().getState() === 'error') {
            console.error('Error loading data:', vectorLayer2.getSource().getLoadingError());
        }
    });

    // Function to handle layer visibility
    function handleLayerVisibility(layer, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        checkbox.addEventListener('change', function() {
            layer.setVisible(this.checked);
        });
    }

    // Function to handle layer opacity
    function handleLayerOpacity(layer, rangeId) {
        const rangeInput = document.getElementById(rangeId);
        rangeInput.addEventListener('input', function() {
            layer.setOpacity(parseFloat(this.value));
        });
        rangeInput.value = String(layer.getOpacity());
    }

    // Function to zoom to a specific location or layer
    function zoomToLocationOrLayer() {
        const searchText = document.getElementById('searchInput').value;
        if (searchText) {
            let foundLayer2 = false;
            let foundLayer1 = false;
            // Check if the search text matches a feature in Layer 2
            vectorLayer2.getSource().forEachFeature(function(feature) {
                if (feature.get('LAYER') === searchText) {
                    const extent = feature.getGeometry().getExtent();
                    map.getView().fit(extent, { duration: 1000 });
                    foundLayer2 = true;
                    return;
                }
            });
            // If not found in Layer 2, check Layer 1
            if (!foundLayer2) {
                vectorLayer1.getSource().forEachFeature(function(feature) {
                    if (feature.get('LAYER') === searchText) {
                        const extent = feature.getGeometry().getExtent();
                        map.getView().fit(extent, { duration: 1000 });
                        foundLayer1 = true;
                        return;
                    }
                });
            }
            // If not found in Layer 1, try to geocode the search text as an address
            if (!foundLayer2 && !foundLayer1) {
                geocodeAddress(searchText);
            }
            // Display error message if nothing is found
            if (!foundLayer2 && !foundLayer1 && !searchText) {
                document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
            } else {
                document.getElementById('errorMessage').textContent = ''; // Clear error message
            }
        } else {
            document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
        }
    }


    // Function to geocode an address and zoom to its location
    function geocodeAddress(address) {
        const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(address);
        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                if (data && data.length > 0) {
                    const location = data[0];
                    const coordinates = [parseFloat(location.lon), parseFloat(location.lat)];
                    map.getView().animate({ center: ol.proj.fromLonLat(coordinates), zoom: 18, duration: 1000 });
                } else {
                    alert('Address not found!');
                }
            })
            .catch(function(error) {
                console.error('Error geocoding address:', error);
            });
    }

    // Handle visibility for OSM layer
    handleLayerVisibility(map.getLayers().item(0), 'visible0');

    // Handle visibility for QGIS layer 1
    handleLayerVisibility(vectorLayer1, 'visible1');

    // Handle visibility for QGIS layer 2
    handleLayerVisibility(vectorLayer2, 'visible2');

    // Handle opacity for QGIS layer 1
    handleLayerOpacity(vectorLayer1, 'opacity1');

    // Handle opacity for QGIS layer 2
    handleLayerOpacity(vectorLayer2, 'opacity2');
</script>
</body>
</html>
